/// A prefix that uniquely identifies this plugin, prepended onto the name of any variable generated by this plugin.
const variablePrefix = "diplomat";

/**
 * Returns a list of languages as a comma-delimited string from the given URL hash.
 */
export function getLanguageFromURL(url) {
  let language = new URLSearchParams(url.hash.substr(1)).get("language");
  return language === "" ? null : language;
}

/**
 * Returns the languages that the user prefers.
 */
export function getLocales() {
  // Check the language "parameter" in the hash.
  let parameter = getLanguageFromURL(window.location)?.split(",");
  // Fall back to the user's language preference.
  let userLocales = parameter ?? navigator.languages ?? [navigator.language];
  let locales = [];
  let localeSet = new Set(); // avoid duplicates
  for (let locale of userLocales) {
    // Add progressively less specific variants of each user-specified locale.
    let components = locale.split("-");
    while (components.length > 0) {
      let parent = components.join("-");
      try {
        // Preflight the parent locale in case it’s incomplete like `en-x`.
        new Intl.Locale(parent);
        if (!localeSet.has(parent)) locales.push(parent);
        localeSet.add(parent);
      } catch {}
      components.pop();
      // A Unicode extension like -u-nu must be followed by another subtag.
      if (components.at(-1)?.length === 2 && components.at(-2) === "u") {
        components.pop();
      }
    }
  }
  return locales;
}

const defaultUnlocalizedNameProperty = "name";

/**
 * Returns a `coalesce` expression that resolves to the feature's name in a
 * language that the user prefers.
 *
 * @param {[string]} locales - Locales of the name fields to include.
 * @param {boolean} options.includesLegacyFields - Whether to include the older fields
 *  that include underscores, for layers that have not transitioned to the
 *  colon syntax.
 * @param {string} options.unlocalizedNameProperty - The name of the property holding the unlocalized name.
 * @param {string} options.localizedNamePropertyFormat - The format of properties holding localized names, where `$1` is replaced by an IETF language tag.
 */
export function getLocalizedNameExpression(locales, options = {}) {
  let nameFields = [
    ...locales.flatMap((l) => {
      let localizedNamePropertyFormat =
        options.localizedNamePropertyFormat || `name:$1`;
      let localizedNameProperty = localizedNamePropertyFormat.replaceAll(
        "$1",
        l,
      );
      let fields = [localizedNameProperty];
      // transportation_label uses an underscore instead of a colon.
      // https://github.com/openmaptiles/openmaptiles/issues/769
      if (options.includesLegacyFields && (l === "de" || l === "en")) {
        fields.push(localizedNameProperty.replaceAll(":", "_"));
      }
      return fields;
    }),
    options.unlocalizedNameProperty || defaultUnlocalizedNameProperty,
  ];
  return ["coalesce", ...nameFields.map((f) => ["get", f])];
}

/**
 * Mutates a `let` expression to have a new value for the variable by the given name, binding the variable if it isn’t already bound to any value.
 *
 * @param {array} letExpr - Expression to update.
 * @param {string} variable - Name of the variable to set.
 * @param {*} value - The variable's new value.
 */
export function updateVariable(letExpr, variable, value) {
  if (!letExpr || letExpr[0] !== "let") return;

  let variableNameIndex = letExpr.indexOf(variable);
  if (variableNameIndex % 2 === 1) {
    letExpr[variableNameIndex + 1] = value;
  } else {
    letExpr.splice(-1, 0, variable, value);
  }
}

const localizedNameVariable = `${variablePrefix}__localizedName`;
const localizedCollatorVariable = `${variablePrefix}__localizedCollator`;
const diacriticInsensitiveCollatorVariable = `${variablePrefix}__diacriticInsensitiveCollator`;

/**
 * Recursively walks an expression, returning a copy of the subexpression after replacing any reference to a specific feature property with a new value in place.
 *
 * @param {array} expression - The expression to transform.
 * @param {string} propertyName - The name of the feature property to look for.
 * @param {*} replacement - The replacement value.
 * @returns {array} The same array as `expression` if `expression` referred to `propertyName`, or `undefined` if `expression` did not refer to `propertyName`.
 */
export function replacePropertyReferences(
  expression,
  propertyName,
  replacement,
) {
  if (!Array.isArray(expression) || expression[0] === "literal") return;
  if (expression[0] === "get") {
    if (expression.length === 2 && expression[1] === propertyName) {
      return replacement;
    }
    return;
  }
  let didReplace = false;
  expression.forEach((arg, idx) => {
    if (!idx) return; // operator can never be a property reference
    let newValue = replacePropertyReferences(arg, propertyName, replacement);
    if (newValue !== undefined) {
      expression[idx] = newValue;
      didReplace = true;
    }
  });
  if (didReplace) return expression;
}

/**
 * The separator to use in inline contexts.
 */
const inlineSeparator = " \u2022 ";

/**
 * Transforms a layer’s `text-field` layout property so that it can be localized by `localizeLayers` later on.
 *
 * The transformed `text-field` property is only modified if it contains a reference to the feature property specified by `unlocalizedNameProperty`. If the layer’s `symbol-placement` layout property is set to either `line` or `line-center`, the resulting text field takes up only one line. Otherwise, the text field for a given feature may span multiple lines if its unlocalized name property is set to a list of values.
 *
 * This function does not introduce any dual language labels. To label features with both the user’s preferred name and the local name simultaneously, pass the layer ID, `text-field`, and `localizedNameWithLocalGloss` into `maplibregl.Map.prototype.setLayoutProperty`.
 *
 * @param {object} layer - The style layer to prepare for localization.
 * @param {string} unlocalizedNameProperty - The name of the feature property that holds the unlocalized name. References to this property are replaced by a more complex expression that can be localized dynamically.
 */
export function prepareLayer(layer, unlocalizedNameProperty) {
  let textField = layer.layout && layer.layout["text-field"];
  if (
    !textField ||
    (textField[0] === "let" && textField.includes(localizedNameVariable))
  ) {
    return;
  }

  let symbolPlacement = layer.layout && layer.layout["symbol-placement"];
  let isInline =
    symbolPlacement === "line" || symbolPlacement === "line-center";
  let separator = isInline ? inlineSeparator : "\n";
  let listValues = listValuesExpression(
    ["var", localizedNameVariable],
    separator,
  );
  let newTextField = replacePropertyReferences(
    textField,
    unlocalizedNameProperty || defaultUnlocalizedNameProperty,
    listValues,
  );
  if (newTextField !== undefined) {
    layer.layout["text-field"] = [
      "let",
      localizedNameVariable,
      "",
      newTextField,
    ];
  }
}

/**
 * Updates localizable variables at the top level of the layer's `text-field` expression based on the given locales.
 *
 * @param {object} layer - The style layer to localize.
 * @param {string} collationLocale - The locale for string comparison purposes.
 * @param {array} localizedNameExpression - An expression that produces a localized name.
 * @param {array} legacyLocalizedNameExpression - An expression that produces a localized name based on legacy properties in OpenMapTiles.
 */
function localizeLayer(
  layer,
  collationLocale,
  localizedNameExpression,
  legacyLocalizedNameExpression,
) {
  if (!("layout" in layer) || !("text-field" in layer.layout)) return;

  let textField = layer.layout["text-field"];

  updateVariable(
    textField,
    localizedNameVariable,
    // https://github.com/openmaptiles/openmaptiles/issues/769
    layer["source-layer"] === "transportation_name"
      ? legacyLocalizedNameExpression
      : localizedNameExpression,
  );

  updateVariable(textField, localizedCollatorVariable, [
    "collator",
    {
      "case-sensitive": false,
      "diacritic-sensitive": true,
      locale: collationLocale,
    },
  ]);

  // Only perform diacritic folding in English. English normally uses few diacritics except when labeling foreign place names on maps.
  updateVariable(textField, diacriticInsensitiveCollatorVariable, [
    "collator",
    {
      "case-sensitive": false,
      "diacritic-sensitive": !/^en\b/.test(collationLocale),
      locale: collationLocale,
    },
  ]);
}

/**
 * Updates localizable variables at the top level of each layer's `text-field` expression based on the given locales.
 *
 * @param {[object]} layers - The style layers to localize.
 * @param {[string]} locales - The locales to insert into each layer.
 * @param {string} options.unlocalizedNameProperty - The name of the property holding the unlocalized name.
 * @param {string} options.localizedNamePropertyFormat - The format of properties holding localized names, where `$1` is replaced by an IETF language tag.
 */
export function localizeLayers(layers, locales = getLocales(), options = {}) {
  let localizedNameExpression = getLocalizedNameExpression(locales, options);
  let legacyLocalizedNameExpression = getLocalizedNameExpression(locales, {
    ...options,
    includesLegacyFields: true,
  });
  for (let layer of layers) {
    localizeLayer(
      layer,
      locales[0],
      localizedNameExpression,
      legacyLocalizedNameExpression,
    );
  }
}

/**
 * Recursively scans a semicolon-delimited value list, replacing a finite number
 * of semicolons with a separator, starting from the given index.
 *
 * This expression nests recursively by the maximum number of replacements. Take
 * special care to minimize this limit, which exponentially increases the length
 * of a property value in JSON. Excessive nesting causes acute performance
 * problems when loading the style.
 *
 * The returned expression can be complex, so use it only once within a property
 * value. To reuse the evaluated value, bind it to a variable in a let
 * expression.
 *
 * @param list The overall string expression to search within.
 * @param separator A string to insert after the value, or an expression that
 *  evaluates to this string.
 * @param listStart A zero-based index into the list at which the search begins.
 * @param numReplacements The maximum number of replacements remaining.
 */
function listValueExpression(
  list,
  separator,
  valueToOmit,
  listStart,
  numReplacements,
) {
  let asIs = ["slice", list, listStart];
  if (numReplacements <= 0) {
    return asIs;
  }

  let iteration = numReplacements;
  let rawSeparator = ";";
  let needleStartVariable = `${variablePrefix}__needleStart${iteration}`;
  let needleEndVariable = `${variablePrefix}__needleEnd${iteration}`;
  let valueVariable = `${variablePrefix}__value${iteration}`;
  let lookaheadVariable = `${variablePrefix}__lookahead${iteration}`;
  let nextListStartVariable = `${variablePrefix}__nextListStart${iteration}`;
  return [
    "let",
    needleStartVariable,
    ["index-of", rawSeparator, list, listStart],
    [
      "case",
      [">=", ["var", needleStartVariable], 0],
      // Found a semicolon.
      [
        "let",
        valueVariable,
        ["slice", list, listStart, ["var", needleStartVariable]],
        needleEndVariable,
        ["+", ["var", needleStartVariable], rawSeparator.length],
        [
          "concat",
          // Start with everything before the semicolon unless it's the value to
          // omit.
          [
            "case",
            ["==", ["var", valueVariable], valueToOmit],
            "",
            ["var", valueVariable],
          ],
          [
            "let",
            lookaheadVariable,
            // Look ahead by one character.
            [
              "slice",
              list,
              ["var", needleEndVariable],
              ["+", ["var", needleEndVariable], rawSeparator.length],
            ],
            [
              "let",
              // Skip past the current value and semicolon for any subsequent
              // searches.
              nextListStartVariable,
              [
                "+",
                ["var", needleEndVariable],
                // Also skip past any escaped semicolon or space padding.
                [
                  "match",
                  ["var", lookaheadVariable],
                  [rawSeparator, " "],
                  rawSeparator.length,
                  0,
                ],
              ],
              [
                "case",
                // If the only remaining value is the value to omit, stop
                // scanning.
                [
                  "==",
                  ["slice", list, ["var", nextListStartVariable]],
                  valueToOmit,
                ],
                "",
                [
                  "concat",
                  [
                    "case",
                    // If the lookahead character is another semicolon, append
                    // an unescaped semicolon.
                    ["==", ["var", lookaheadVariable], rawSeparator],
                    rawSeparator,
                    // Otherwise, if the value is the value to omit, do nothing.
                    ["==", ["var", valueVariable], valueToOmit],
                    "",
                    // Otherwise, append the passed-in separator.
                    separator,
                  ],
                  // Recurse for the next value in the value list.
                  listValueExpression(
                    list,
                    separator,
                    valueToOmit,
                    ["var", nextListStartVariable],
                    numReplacements - 1,
                  ),
                ],
              ],
            ],
          ],
        ],
      ],
      // No semicolons left in the string, so stop looking and append the value as is.
      asIs,
    ],
  ];
}

/**
 * Maximum number of values in a semicolon-delimited list of values.
 *
 * Increasing this constant deepens recursion for replacing delimiters in the
 * list, potentially affecting style loading performance.
 */
const maxValueListLength = 3;

/**
 * Returns an expression interpreting the given string as a list of tag values,
 * pretty-printing the standard semicolon delimiter with the given separator.
 *
 * https://wiki.openstreetmap.org/wiki/Semi-colon_value_separator
 *
 * The returned expression can be complex, so use it only once within a property
 * value. To reuse the evaluated value, bind it to a variable in a let
 * expression.
 *
 * @param valueList A semicolon-delimited list of values.
 * @param separator A string to insert between each value, or an expression that
 *  evaluates to this string.
 */
export function listValuesExpression(valueList, separator, valueToOmit) {
  let maxSeparators = maxValueListLength - 1;
  let valueListVariable = `${variablePrefix}__valueList`;
  let valueToOmitVariable = `${variablePrefix}__valueToOmit`;
  return [
    "let",
    valueListVariable,
    valueList,
    valueToOmitVariable,
    valueToOmit || ";",
    listValueExpression(
      ["var", valueListVariable],
      separator,
      ["var", valueToOmitVariable],
      0,
      maxSeparators,
    ),
  ];
}

/**
 * The names in the user's preferred language, each on a separate line.
 */
export const localizedName = [
  "let",
  localizedNameVariable,
  "",
  listValuesExpression(["var", localizedNameVariable], "\n"),
];

/**
 * The names in the user's preferred language, all on the same line.
 */
export const localizedNameInline = [
  "let",
  localizedNameVariable,
  "",
  listValuesExpression(["var", localizedNameVariable], inlineSeparator),
];

/**
 * Returns an expression that tests whether the target has the given prefix,
 * respecting word boundaries.
 */
function startsWithExpression(target, candidatePrefix, collator) {
  // "Quebec City" vs. "Québec", "Washington, D.C." vs. "Washington"
  let wordBoundaries = " ,";
  return [
    "all",
    [
      "==",
      ["slice", target, 0, ["length", candidatePrefix]],
      candidatePrefix,
      collator,
    ],
    [
      "in",
      [
        "slice",
        // Pad the target in case the prefix matches exactly.
        // "Montreal " vs. "Montréal"
        ["concat", target, wordBoundaries[0]],
        ["length", candidatePrefix],
        ["+", ["length", candidatePrefix], 1],
      ],
      wordBoundaries,
    ],
  ];
}

function overwritePrefixExpression(target, newPrefix) {
  return ["concat", newPrefix, ["slice", target, ["length", newPrefix]]];
}

/**
 * Returns an expression that tests whether the target has the given suffix,
 * respecting word boundaries.
 */
function endsWithExpression(target, candidateSuffix, collator) {
  let wordBoundary = " ";
  let suffixStartVariable = `${variablePrefix}__suffixStart`;
  return [
    "let",
    suffixStartVariable,
    ["-", ["length", target], ["length", candidateSuffix]],
    [
      "all",
      [
        "==",
        ["slice", target, ["var", suffixStartVariable]],
        candidateSuffix,
        collator,
      ],
      [
        "==",
        [
          "slice",
          target,
          ["-", ["var", suffixStartVariable], 1],
          ["var", suffixStartVariable],
        ],
        wordBoundary,
      ],
    ],
  ];
}

function overwriteSuffixExpression(target, newSuffix) {
  return [
    "concat",
    ["slice", target, 0, ["-", ["length", target], ["length", newSuffix]]],
    newSuffix,
  ];
}

const localizedNameListVariable = `${variablePrefix}__localizedNameList`;
const nameListVariable = `${variablePrefix}__nameList`;

/**
 * The name in the user's preferred language, followed by the name in the local
 * language in parentheses if it differs.
 */
export const localizedNameWithLocalGloss = [
  "let",
  localizedNameVariable,
  "",
  localizedCollatorVariable,
  ["collator", {}],
  diacriticInsensitiveCollatorVariable,
  ["collator", {}],
  [
    "let",
    localizedNameListVariable,
    listValuesExpression(["var", localizedNameVariable], "\n"),
    [
      "case",
      // If the name in the preferred and local languages match exactly...
      [
        "==",
        ["var", localizedNameVariable],
        ["get", "name"],
        ["var", localizedCollatorVariable],
      ],
      // ...just pick one.
      ["format", ["var", localizedNameListVariable]],
      [
        "let",
        nameListVariable,
        listValuesExpression(["get", "name"], "\n"),
        [
          "case",
          // If the name in the preferred language is the same as the name in the
          // local language except for the omission of diacritics and/or the addition
          // of a suffix (e.g., "City" in English)...
          startsWithExpression(
            ["var", localizedNameVariable],
            ["get", "name"],
            ["var", diacriticInsensitiveCollatorVariable],
          ),
          // ...then replace the common prefix with the local name.
          [
            "format",
            overwritePrefixExpression(
              ["var", localizedNameVariable],
              ["var", nameListVariable],
            ),
          ],
          // If the name in the preferred language is the same as the name in the
          // local language except for the omission of diacritics and/or the addition
          // of a prefix (e.g., "City of" in English or "Ciudad de" in Spanish)...
          endsWithExpression(
            ["var", localizedNameVariable],
            ["get", "name"],
            ["var", diacriticInsensitiveCollatorVariable],
          ),
          // ...then replace the common suffix with the local name.
          [
            "format",
            overwriteSuffixExpression(
              ["var", localizedNameVariable],
              ["var", nameListVariable],
            ),
          ],
          // Otherwise, gloss the name in the local language if it differs from the
          // localized name.
          [
            "format",
            ["var", localizedNameListVariable],
            "\n",
            "(\u2068",
            { "font-scale": 0.8 },
            listValuesExpression(["get", "name"], inlineSeparator, [
              "var",
              localizedNameVariable,
            ]),
            { "font-scale": 0.8 },
            "\u2069)",
            { "font-scale": 0.8 },
          ],
        ],
      ],
    ],
  ],
];

/**
 * ISO 3166-1 alpha-2 country codes by ISO 3166-1 alpha-3 code.
 *
 * Source: https://www.cia.gov/the-world-factbook/references/country-data-codes/
 */
const iso3166_1_alpha_2_by_3 = {
  ABW: "AW",
  AFG: "AF",
  AGO: "AO",
  AIA: "AI",
  ALB: "AL",
  AND: "AD",
  ARE: "AE",
  ARG: "AR",
  ARM: "AM",
  ASM: "AS",
  ATA: "AQ",
  ATF: "TF",
  ATG: "AG",
  AUS: "AU",
  AUT: "AT",
  AZE: "AZ",
  BDI: "BI",
  BEL: "BE",
  BEN: "BJ",
  BFA: "BF",
  BGD: "BD",
  BGR: "BG",
  BHR: "BH",
  BHS: "BS",
  BIH: "BA",
  BLM: "BL",
  BLR: "BY",
  BLZ: "BZ",
  BMU: "BM",
  BOL: "BO",
  BRA: "BR",
  BRB: "BB",
  BRN: "BN",
  BTN: "BT",
  BVT: "BV",
  BWA: "BW",
  CAF: "CF",
  CAN: "CA",
  CCK: "CC",
  CHE: "CH",
  CHL: "CL",
  CHN: "CN",
  CIV: "CI",
  CMR: "CM",
  COD: "CD",
  COG: "CG",
  COK: "CK",
  COL: "CO",
  COM: "KM",
  CPV: "CV",
  CRI: "CR",
  CUB: "CU",
  CUW: "CW",
  CXR: "CX",
  CYM: "KY",
  CYP: "CY",
  CZE: "CZ",
  DEU: "DE",
  DJI: "DJ",
  DMA: "DM",
  DNK: "DK",
  DOM: "DO",
  DZA: "DZ",
  ECU: "EC",
  EGY: "EG",
  ERI: "ER",
  ESH: "EH",
  ESP: "ES",
  EST: "EE",
  ETH: "ET",
  FIN: "FI",
  FJI: "FJ",
  FLK: "FK",
  FRA: "FR",
  FRO: "FO",
  FSM: "FM",
  FXX: "FX",
  GAB: "GA",
  GBR: "GB",
  GEO: "GE",
  GGY: "GG",
  GHA: "GH",
  GIB: "GI",
  GIN: "GN",
  GLP: "GP",
  GMB: "GM",
  GNB: "GW",
  GNQ: "GQ",
  GRC: "GR",
  GRD: "GD",
  GRL: "GL",
  GTM: "GT",
  GUF: "GF",
  GUM: "GU",
  GUY: "GY",
  HKG: "HK",
  HMD: "HM",
  HND: "HN",
  HRV: "HR",
  HTI: "HT",
  HUN: "HU",
  IDN: "ID",
  IMN: "IM",
  IND: "IN",
  IOT: "IO",
  IRL: "IE",
  IRN: "IR",
  IRQ: "IQ",
  ISL: "IS",
  ISR: "IL",
  ITA: "IT",
  JAM: "JM",
  JEY: "JE",
  JOR: "JO",
  JPN: "JP",
  KAZ: "KZ",
  KEN: "KE",
  KGZ: "KG",
  KHM: "KH",
  KIR: "KI",
  KNA: "KN",
  KOR: "KR",
  KWT: "KW",
  LAO: "LA",
  LBN: "LB",
  LBR: "LR",
  LBY: "LY",
  LCA: "LC",
  LIE: "LI",
  LKA: "LK",
  LSO: "LS",
  LTU: "LT",
  LUX: "LU",
  LVA: "LV",
  MAC: "MO",
  MAF: "MF",
  MAR: "MA",
  MCO: "MC",
  MDA: "MD",
  MDG: "MG",
  MDV: "MV",
  MEX: "MX",
  MHL: "MH",
  MKD: "MK",
  MLI: "ML",
  MLT: "MT",
  MMR: "MM",
  MNE: "ME",
  MNG: "MN",
  MNP: "MP",
  MOZ: "MZ",
  MRT: "MR",
  MSR: "MS",
  MTQ: "MQ",
  MUS: "MU",
  MWI: "MW",
  MYS: "MY",
  MYT: "YT",
  NAM: "NA",
  NCL: "NC",
  NER: "NE",
  NFK: "NF",
  NGA: "NG",
  NIC: "NI",
  NIU: "NU",
  NLD: "NL",
  NOR: "NO",
  NPL: "NP",
  NRU: "NR",
  NZL: "NZ",
  OMN: "OM",
  PAK: "PK",
  PAN: "PA",
  PCN: "PN",
  PER: "PE",
  PHL: "PH",
  PLW: "PW",
  PNG: "PG",
  POL: "PL",
  PRI: "PR",
  PRK: "KP",
  PRT: "PT",
  PRY: "PY",
  PSE: "PS",
  PYF: "PF",
  QAT: "QA",
  REU: "RE",
  ROU: "RO",
  RUS: "RU",
  RWA: "RW",
  SAU: "SA",
  SDN: "SD",
  SEN: "SN",
  SGP: "SG",
  SGS: "GS",
  SHN: "SH",
  SJM: "SJ",
  SLB: "SB",
  SLE: "SL",
  SLV: "SV",
  SMR: "SM",
  SOM: "SO",
  SPM: "PM",
  SRB: "RS",
  SSD: "SS",
  STP: "ST",
  SUR: "SR",
  SVK: "SK",
  SVN: "SI",
  SWE: "SE",
  SWZ: "SZ",
  SXM: "SX",
  SYC: "SC",
  SYR: "SY",
  TCA: "TC",
  TCD: "TD",
  TGO: "TG",
  THA: "TH",
  TJK: "TJ",
  TKL: "TK",
  TKM: "TM",
  TLS: "TL",
  TON: "TO",
  TTO: "TT",
  TUN: "TN",
  TUR: "TR",
  TUV: "TV",
  TWN: "TW",
  TZA: "TZ",
  UGA: "UG",
  UKR: "UA",
  UMI: "UM",
  URY: "UY",
  USA: "US",
  UZB: "UZ",
  VAT: "VA",
  VCT: "VC",
  VEN: "VE",
  VGB: "VG",
  VIR: "VI",
  VNM: "VN",
  VUT: "VU",
  WLF: "WF",
  WSM: "WS",
  YEM: "YE",
  ZAF: "ZA",
  ZMB: "ZM",
  ZWE: "ZW",
};

const countryNamesByCodeVariable = `${variablePrefix}__countryNamesByCode`;

/**
 * Returns a table of country names in the user’s preferred language by ISO 3166-1 alpha-3 code.
 *
 * @param {[string]} locales - The locales for formatting the country names.
 * @param {boolean} options.uppercase Whether to write the country names in all uppercase, respecting the locale’s case conventions.
 */
export function getLocalizedCountryNames(locales, options = {}) {
  let countryNames = new Intl.DisplayNames(locales, {
    type: "region",
    fallback: "none",
  });
  return Object.fromEntries(
    Object.entries(iso3166_1_alpha_2_by_3).map((e) => {
      let name = countryNames.of(e[1]);
      if (name && options?.uppercase) {
        // Neither the upcase expression operator nor the text-transform layout property is locale-aware, so uppercase the name upfront.
        name = name
          .toLocaleUpperCase(locales)
          // Word boundaries are less discernible in uppercase text, so pad each word by an additional space.
          .replaceAll(" ", "  ");
      }
      return [e[0], name];
    }),
  );
}

/**
 * Returns the global state that Diplomat needs to fully localize the style.
 *
 * @param {[string]} locales - The locales for formatting the country names.
 * @param {boolean} options.uppercaseCountryNames Whether to write country names in all uppercase, respecting the locale’s case conventions.
 */
export function getGlobalStateForLocalization(locales, options = {}) {
  let state = {};
  state[countryNamesByCodeVariable] = getLocalizedCountryNames(locales, {
    uppercase: options?.uppercaseCountryNames,
  });
  return state;
}

/**
 * Returns an expression that converts the given country code to a human-readable name in the user's preferred language.
 *
 * @param {array} code An expression that evaluates to an ISO 3166-1 alpha-3 country code.
 */
export function getLocalizedCountryNameExpression(code) {
  return [
    "let",
    "code",
    code,
    [
      "coalesce",
      [
        "get",
        ["var", "code"],
        [
          "coalesce",
          ["global-state", countryNamesByCodeVariable],
          ["literal", {}],
        ],
      ],
      // Fall back to the country code in parentheses.
      ["concat", "(", ["var", "code"], ")"],
    ],
  ];
}

if (typeof window !== "undefined" && "maplibregl" in window) {
  maplibregl.Diplomat = {
    getGlobalStateForLocalization,
    getLanguageFromURL,
    getLocales,
    getLocalizedCountryNameExpression,
    listValuesExpression,
    localizeLayers,
    localizedName,
    localizedNameInline,
    localizedNameWithLocalGloss,
  };

  /**
   * Updates each style layer's `text-field` value to match the given locales, upgrading any unlocalizable layer along the way.
   *
   * This method ugprades unlocalizable layers to localized multiline or inline labels depending on the `symbol-placement` layout property. To add a dual language label to a layer, set its `text-field` layout property manually using the `localizedNameWithLocalGloss` constant.
   *
   * @param {[string]} locales - The locales to insert into each layer.
   * @param {[string]} options.layers - If specified, only these style layers will be made localizable. Otherwise, any style layer that uses the unlocalized name property will be made localizable.
   * @param {string} options.unlocalizedNameProperty - The name of the property holding the unlocalized name.
   * @param {string} options.localizedNamePropertyFormat - The format of properties holding localized names, where `$1` is replaced by an IETF language tag.
   * @param {boolean} options.uppercaseCountryNames Whether to write country names in all uppercase, respecting the locale’s case conventions.
   */
  maplibregl.Map.prototype.localizeStyle = function (
    locales = getLocales(),
    options = {},
  ) {
    let style = this.getStyle();

    let localizedNameExpression = getLocalizedNameExpression(locales, options);
    let legacyLocalizedNameExpression = getLocalizedNameExpression(locales, {
      ...options,
      includesLegacyFields: true,
    });

    let layers = options.layers?.map((n) => style.layers[n]) || style.layers;
    for (let layer of layers) {
      prepareLayer(layer, options?.unlocalizedNameProperty);
      localizeLayer(
        layer,
        locales[0],
        localizedNameExpression,
        legacyLocalizedNameExpression,
      );
    }

    let countryNames = getLocalizedCountryNames(locales, {
      uppercase: options?.uppercaseCountryNames,
    });
    this.setGlobalStateProperty(countryNamesByCodeVariable, countryNames);

    this.setStyle(style);
  };
}
